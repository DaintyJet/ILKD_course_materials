## Lecture 05: Monday, 17 June 2024

### Announcements

1. [P0](/assignments/P0.md) initial submission: due in one week

1. Take note of the style requirements in
[procedures](/procedures.md) 

    1. Check your patches with the kernel tree's
[`checkpatch.pl`](https://raw.githubusercontent.com/torvalds/linux/master/scripts/checkpatch.pl)
as described in our procedures and policies

---

### Review

1. L0{2,3,4} covered building a minimal Linux distribution from scratch

    1. We compiled and booted a kernel with a minimal, busybox-based userspace

    1. We mounted the `/proc` and `sysfs` kernel-backed filesystems

    1. We built and installed a C compiler (`tcc`) and C library (`glibc`)

1. L04 concluded with a quick tour of some advanced features of C used by the kernel

    1. Our main focus was on the preprocessor 

    1. The last example was the arm64 fault-handling code defining the syscall vectors

---

### Lecture overview

1. Let's dive into the lifecycle of a system call

    1. We compare `arm64` and `x86_64` implementations 

    1. The system call begins in userspace with a special instruction

    1. This brings us back to where we left off at the end of L04

---

### Practical reference

Linux defines the entry points for
[arm64 syscalls here](https://elixir.bootlin.com/linux/latest/source/arch/arm64/kernel/entry.S)
